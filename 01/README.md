# Задание 1

---

- Низкоуровневые и высокоуровневые функции
- Работа с моторами
- Функция `void setMotors(int L, int R)`

---

## Низкоуровневые и высокоуровневые функции

**Низкоуровневые функции** - это функции, реализация которых напрямую зависит от используемых компонентов *(моторов, сенсоров и прочего)*. **Высокоуровневые функции** - функции, не зависящие от
используемых компонентов. Высокоуровневые функции используют низкоуровневые - так при замене оборудования не придётся изменять реализацию алгоритмов.

К низкоуровневым функциям относятся функции опроса датчиков, работы с модулями и тому подобного. К высокоуровневым - функции, реализующие алгоритмы движения (релейный регулятор, ПИД-регулятор),
перевозку объектов манипулятором и прочее.

---

## Подключение моторов

Мы используем моторы GA-25 с платой-энкодером. Шлейф данной платы устроен следующим образом:

| Цвет    | Назначение     |
|---------|----------------|
| Красный | Вывод мотора   |
| Черный  | `GND` энкодера |
| Желтый  | Фаза энкодера  |
| Зеленый | Фаза энкодера  |
| Синий   | `+5V` энкодера |
| Белый   | Вывод мотора   |

---

## Код

Функция `setMotors` принимает значения типа `int` (16-битные целые числа на AVR) - скорости для левого и правого мотора (`int L` и `int R`, соответственно).

```cpp
void setMotors(int L, int R)
```

Во избежание неопределённого поведения при установке ШИМ, ограничим значения L и R:

```cpp
L = constrain(L, -255, 255);
R = constrain(R, -255, 255);
```

Далее подадим сигналы на драйвер моторов - цифровой сигнал направления на пины `4` и `7` и аналоговый (ШИМ) сигнал скорости на пины `5` и `6`.

```cpp
digitalWrite(4, L < 0);
digitalWrite(7, R < 0);
analogWrite(5, abs(L));
analogWrite(6, abs(R));
```

**Объяснение логики направления:**

- При `L > 0` и `R > 0` - движение вперед (пины направления = LOW)
- При `L < 0` и `R < 0` - движение назад (пины направления = HIGH)
- При разных знаках - повороты

[Скетч для Arduino UNO](./01.ino)

